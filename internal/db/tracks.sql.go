// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tracks.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const deleteTracksByNavidromeIDs = `-- name: DeleteTracksByNavidromeIDs :exec
DELETE FROM tracks
WHERE navidrome_id IN (/*SLICE:nav_ids*/?)
`

func (q *Queries) DeleteTracksByNavidromeIDs(ctx context.Context, navIds []string) error {
	query := deleteTracksByNavidromeIDs
	var queryParams []interface{}
	if len(navIds) > 0 {
		for _, v := range navIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nav_ids*/?", strings.Repeat(",?", len(navIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nav_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const insertTrackAudioJob = `-- name: InsertTrackAudioJob :exec
INSERT INTO track_audio_analysis (
  track_id,
  status,
  processed_at,
  error,
  attempts,
  last_attempt_at
) VALUES (?, ?, ?, ?, ?, ?)
`

type InsertTrackAudioJobParams struct {
	TrackID       int64          `json:"track_id"`
	Status        string         `json:"status"`
	ProcessedAt   sql.NullString `json:"processed_at"`
	Error         sql.NullString `json:"error"`
	Attempts      int64          `json:"attempts"`
	LastAttemptAt sql.NullString `json:"last_attempt_at"`
}

func (q *Queries) InsertTrackAudioJob(ctx context.Context, arg InsertTrackAudioJobParams) error {
	_, err := q.db.ExecContext(ctx, insertTrackAudioJob,
		arg.TrackID,
		arg.Status,
		arg.ProcessedAt,
		arg.Error,
		arg.Attempts,
		arg.LastAttemptAt,
	)
	return err
}

const insertTrackEmbeddingJob = `-- name: InsertTrackEmbeddingJob :exec
INSERT INTO track_embedding_jobs (
  track_id,
  status,
  processed_at,
  error,
  attempts,
  last_attempt_at
) VALUES (?, ?, ?, ?, ?, ?)
`

type InsertTrackEmbeddingJobParams struct {
	TrackID       int64          `json:"track_id"`
	Status        string         `json:"status"`
	ProcessedAt   sql.NullString `json:"processed_at"`
	Error         sql.NullString `json:"error"`
	Attempts      int64          `json:"attempts"`
	LastAttemptAt sql.NullString `json:"last_attempt_at"`
}

func (q *Queries) InsertTrackEmbeddingJob(ctx context.Context, arg InsertTrackEmbeddingJobParams) error {
	_, err := q.db.ExecContext(ctx, insertTrackEmbeddingJob,
		arg.TrackID,
		arg.Status,
		arg.ProcessedAt,
		arg.Error,
		arg.Attempts,
		arg.LastAttemptAt,
	)
	return err
}

const listTrackSyncStatus = `-- name: ListTrackSyncStatus :many
SELECT track_id, navidrome_id, last_synced_at FROM navidrome_track_sync_status
`

type ListTrackSyncStatusRow struct {
	TrackID      int64  `json:"track_id"`
	NavidromeID  string `json:"navidrome_id"`
	LastSyncedAt string `json:"last_synced_at"`
}

func (q *Queries) ListTrackSyncStatus(ctx context.Context) ([]ListTrackSyncStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrackSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTrackSyncStatusRow
	for rows.Next() {
		var i ListTrackSyncStatusRow
		if err := rows.Scan(&i.TrackID, &i.NavidromeID, &i.LastSyncedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTrackID = `-- name: SelectTrackID :one
SELECT id FROM tracks WHERE navidrome_id = ?
`

func (q *Queries) SelectTrackID(ctx context.Context, navidromeID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, selectTrackID, navidromeID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertTrack = `-- name: UpsertTrack :exec
INSERT INTO tracks (
  navidrome_id,
  title,
  artist,
  artist_id,
  album,
  album_id,
  album_artist,
  genre,
  year,
  track_number,
  disc_number,
  duration_seconds,
  bitrate,
  file_size,
  path,
  content_type,
  suffix,
  created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(navidrome_id) DO UPDATE SET
  title = excluded.title,
  artist = excluded.artist,
  artist_id = excluded.artist_id,
  album = excluded.album,
  album_id = excluded.album_id,
  album_artist = excluded.album_artist,
  genre = excluded.genre,
  year = excluded.year,
  track_number = excluded.track_number,
  disc_number = excluded.disc_number,
  duration_seconds = excluded.duration_seconds,
  bitrate = excluded.bitrate,
  file_size = excluded.file_size,
  path = excluded.path,
  content_type = excluded.content_type,
  suffix = excluded.suffix,
  created_at = excluded.created_at
`

type UpsertTrackParams struct {
	NavidromeID     string         `json:"navidrome_id"`
	Title           string         `json:"title"`
	Artist          string         `json:"artist"`
	ArtistID        sql.NullString `json:"artist_id"`
	Album           string         `json:"album"`
	AlbumID         sql.NullString `json:"album_id"`
	AlbumArtist     sql.NullString `json:"album_artist"`
	Genre           sql.NullString `json:"genre"`
	Year            sql.NullInt64  `json:"year"`
	TrackNumber     sql.NullInt64  `json:"track_number"`
	DiscNumber      sql.NullInt64  `json:"disc_number"`
	DurationSeconds int64          `json:"duration_seconds"`
	Bitrate         sql.NullInt64  `json:"bitrate"`
	FileSize        sql.NullInt64  `json:"file_size"`
	Path            string         `json:"path"`
	ContentType     sql.NullString `json:"content_type"`
	Suffix          string         `json:"suffix"`
	CreatedAt       string         `json:"created_at"`
}

func (q *Queries) UpsertTrack(ctx context.Context, arg UpsertTrackParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrack,
		arg.NavidromeID,
		arg.Title,
		arg.Artist,
		arg.ArtistID,
		arg.Album,
		arg.AlbumID,
		arg.AlbumArtist,
		arg.Genre,
		arg.Year,
		arg.TrackNumber,
		arg.DiscNumber,
		arg.DurationSeconds,
		arg.Bitrate,
		arg.FileSize,
		arg.Path,
		arg.ContentType,
		arg.Suffix,
		arg.CreatedAt,
	)
	return err
}

const upsertTrackSyncStatus = `-- name: UpsertTrackSyncStatus :exec
INSERT INTO navidrome_track_sync_status (
  track_id,
  navidrome_id,
  last_synced_at,
  sync_id
) VALUES (?, ?, ?, ?)
ON CONFLICT(track_id) DO UPDATE SET
  last_synced_at = excluded.last_synced_at,
  sync_id = excluded.sync_id
`

type UpsertTrackSyncStatusParams struct {
	TrackID      int64  `json:"track_id"`
	NavidromeID  string `json:"navidrome_id"`
	LastSyncedAt string `json:"last_synced_at"`
	SyncID       int64  `json:"sync_id"`
}

func (q *Queries) UpsertTrackSyncStatus(ctx context.Context, arg UpsertTrackSyncStatusParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrackSyncStatus,
		arg.TrackID,
		arg.NavidromeID,
		arg.LastSyncedAt,
		arg.SyncID,
	)
	return err
}
